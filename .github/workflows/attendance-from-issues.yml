name: Build attendance codes from issues

on:
  issues:
    types: [opened, edited]
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  parse-and-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Verify tooling
        run: |
          set -euo pipefail
          git --version
          gh --version || echo "gh CLI not found"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Parse issue and commit codes JSON
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          REPO: ${{ github.repository }}
          TARGET_BRANCH: main
        run: |
          set -euo pipefail
          python3 - << 'PY'
          import os, re, json, subprocess, sys, pathlib, urllib.request, base64

          issue_no = int(os.environ['ISSUE_NUMBER'])
          title = os.environ.get('ISSUE_TITLE') or ''
          body = os.environ.get('ISSUE_BODY') or ''
          repo = os.environ['REPO']
          target_branch = os.environ.get('TARGET_BRANCH','main')

          def parse_issue_form_text(body_text: str):
              """Parse GitHub Issue Form sections: Course code, Week number, Attendance codes.

              Returns (course:str|None, week:str|None, pairs:list[(slot,code)]).
              """
              course = None
              week = None
              pairs = []

              # Common Issue Forms render as markdown headings like:
              # ### Course code\nFIT1111\n\n### Week number\n3\n\n### Attendance codes\n...
              sec = {
                  'course': r"(?mis)^###\s*Course\s*code\s*\n+([^\n#]+)",
                  'week': r"(?mis)^###\s*Week\s*number\s*\n+([^\n#]+)",
                  'codes': r"(?mis)^###\s*Attendance\s*codes\s*\n+(.+?)(?:\n###\s|\Z)",
              }
              m = re.search(sec['course'], body_text)
              if m:
                  course = re.sub(r"[^A-Za-z0-9]+", "", m.group(1)).upper() or None
              m = re.search(sec['week'], body_text)
              if m:
                  wk = re.sub(r"[^0-9]+", "", m.group(1))
                  week = wk if wk else None
              m = re.search(sec['codes'], body_text)
              if m:
                  code_block = m.group(1)
                  for line in code_block.splitlines():
                      line = line.strip()
                      if not line:
                          continue
                      # Accept optional list markers and flexible spacing
                      mm = re.match(r"^[-*+]?\s*([^:]+?)\s*:\s*([A-Za-z0-9]{4,12})\s*$", line)
                      if mm:
                          slot, code = mm.group(1).strip(), mm.group(2).strip().upper()
                          pairs.append((slot, code))
              return course, week, pairs

          def call_gemini_api(api_key, issue_title, issue_body):
              # Note: Using gemini-1.5-flash as gemini-2.5-flash is not a valid model at this time.
              prompt = f'''
          From the following GitHub issue title and body, extract the course code, week number, and attendance codes.
          - The course code is a 3-letter, 4-digit code (e.g., FIT1111).
          - The week number is an integer.
          - The attendance codes are pairs of a slot (e.g., "Workshop 1") and a code (e.g., "JZXBA").

          Return the result as a single, minified JSON object with no markdown formatting. The JSON object should have these keys: "course", "week", "codes".
          - The "course" value should be a string.
          - The "week" value should be an integer.
          - The "codes" key should hold an array of objects, where each object has a "slot" and "code" key.

          If the course code or week number cannot be found, return null for those fields.
          If no attendance codes can be found, return an empty array for the "codes" field.

          ---
          Issue Title: {issue_title}
          ---
          Issue Body:
          {issue_body}
          '''
              
              api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}"
              
              headers = {"Content-Type": "application/json"}
              
              data = {
                  "contents": [{
                      "parts": [{
                          "text": prompt
                      }]
                  }],
                  "generationConfig": {
                      "response_mime_type": "application/json",
                  }
              }
              
              req = urllib.request.Request(api_url, data=json.dumps(data).encode("utf-8"), headers=headers)
              
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status == 200:
                          response_body = response.read().decode("utf-8")
                          response_json = json.loads(response_body)
                          return response_json['candidates'][0]['content']['parts'][0]['text']
              except urllib.error.HTTPError as e:
                  print(f"Gemini API request failed with status: {e.code}")
                  print(e.read().decode())
                  return None
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")
                  return None

          def call_gemini_api_with_image(api_key, image_data, mime_type):
              prompt = '''
              From the attached image, extract the course code, week number, and attendance codes.
              The course code is a 3-letter, 4-digit code (e.g., FIT1111).
              The week number is an integer.
              The attendance codes are pairs of a slot (e.g., "Workshop 1") and a code (e.g., "JZXBA").

              Return the result as a single, minified JSON object with no markdown formatting. The JSON object should have these keys: "course", "week", "codes".
              - The "course" value should be a string.
              - The "week" value should be an integer.
              - The "codes" key should hold an array of objects, where each object has a "slot" and "code" key.

              If the course code or week number cannot be found, return null for those fields.
              If no attendance codes can be found, return an empty array for the "codes" field.
              '''
              
              api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}"
              
              headers = {"Content-Type": "application/json"}
              
              data = {
                  "contents": [{
                      "parts": [
                          {"text": prompt},
                          {
                              "inline_data": {
                                  "mime_type": mime_type,
                                  "data": image_data
                              }
                          }
                      ]
                  }],
                  "generationConfig": {
                      "response_mime_type": "application/json",
                  }
              }
              
              req = urllib.request.Request(api_url, data=json.dumps(data).encode("utf-8"), headers=headers)
              
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status == 200:
                          response_body = response.read().decode("utf-8")
                          response_json = json.loads(response_body)
                          return response_json['candidates'][0]['content']['parts'][0]['text']
              except urllib.error.HTTPError as e:
                  print(f"Gemini API request failed with status: {e.code}")
                  print(e.read().decode())
                  return None
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")
                  return None

          # First, try deterministic parsing from the Issue Form
          course, week, pairs = parse_issue_form_text(body)

          gemini_api_key = os.environ.get('GEMINI_API_KEY')

          # If still missing, optionally try Gemini on text
          if (not course or not week or not pairs) and gemini_api_key:
              extracted_data_json = call_gemini_api(gemini_api_key, title, body)
              if extracted_data_json:
                  try:
                      extracted_data = json.loads(extracted_data_json)
                      course = course or extracted_data.get("course")
                      week = week or (str(extracted_data.get("week")) if extracted_data.get("week") else None)
                      if not pairs and extracted_data.get("codes"):
                          for item in extracted_data.get("codes"):
                              pairs.append((item.get("slot"), item.get("code")))
                  except json.JSONDecodeError:
                      print("Failed to decode JSON from Gemini text response.")

          # If still no pairs, try image OCR via Gemini (if key present)
          if not pairs:
              img_urls = re.findall(r'!\[[^\]]*\]\((https?://[^)]+)\)', body)
              if img_urls:
                  if not gemini_api_key:
                      print("Image(s) found but GEMINI_API_KEY not set; skipping OCR.")
                  
                  for url in img_urls:
                      try:
                          with urllib.request.urlopen(url) as resp:
                              image_bytes = resp.read()
                              content_type = resp.info().get_content_type()
                              image_b64 = base64.b64encode(image_bytes).decode("utf-8")
                              if not gemini_api_key:
                                  continue
                              extracted_data_json = call_gemini_api_with_image(gemini_api_key, image_b64, content_type)
                              if extracted_data_json:
                                  extracted_data = json.loads(extracted_data_json)
                                  course = course or extracted_data.get("course")
                                  week = week or (str(extracted_data.get("week")) if extracted_data.get("week") else None)
                                  if not pairs and extracted_data.get("codes"):
                                      for item in extracted_data.get("codes"):
                                          pairs.append((item.get("slot"), item.get("code")))
                                  # If we got something from the first image, we can stop.
                                  if pairs:
                                      break
                      except Exception as e:
                          print(f"Failed to process image at {url}: {e}")

          # If still no pairs, ask user to provide proper text
          if not pairs:
            comment = (
              "Could not identify attendance codes from the issue.\n\n"
              "Please provide the codes in the issue body in the following format, or upload a clearer screenshot:\n\n"
              "```\nWorkshop 1: JZXBA\nWorkshop 2: AJYV7\nApplied 1: 6B7UF\n...\n```\n\nAlso, please specify the following in the body:\n\n- Course code (e.g., FIT1111)\n- Week number (e.g., Week 3)\n\nThe workflow will automatically retry after the issue is updated."
            )
            subprocess.run([
              'gh','api',
              f'repos/{repo}/issues/{issue_no}/comments',
              '--method','POST','-f',f'body={comment}'
            ], check=False)
            sys.exit(0)

          # If pairs are found but course/week missing, request them
          if not course or not week:
            missing = []
            if not course: missing.append('课程代码（如 FIT1111）')
            if not week: missing.append('Week 编号（如 Week 3）')
            comment = (
              "Attendance codes have been identified, but the following information is missing: " + ", ".join(missing) + ".\n\n"
              "Please add the missing information to the issue body:\n\n- Course code (e.g., FIT1111)\n- Week number (e.g., Week 3)\n\nThe JSON file will be generated automatically after the issue is updated."
            )
            subprocess.run([
              'gh','api',
              f'repos/{repo}/issues/{issue_no}/comments',
              '--method','POST','-f',f'body={comment}'
            ], check=False)
            sys.exit(0)

          # Update issue title
          new_title = f"{course} Week {week}: Attendance codes"
          subprocess.run([
            'gh','issue','edit',str(issue_no),
            '--title', new_title
          ], check=False)

          # Build JSON entries for codes
          entries = []
          for slot, code in pairs:
            entries.append({
              'slot': slot.strip(),
              'date': None,
              'code': code.strip().upper(),
            })

          # File path under data/{course}/{week}.json
          safe_course = re.sub(r'[^A-Za-z0-9]+','', course).upper()
          safe_week = re.sub(r'[^0-9]+','', week)
          if not safe_week:
            raise SystemExit('Week number must be an integer')
          out_dir = pathlib.Path('data') / safe_course
          out_dir.mkdir(parents=True, exist_ok=True)
          filename = str(out_dir / f"{safe_week}.json")
          with open(filename,'w',encoding='utf-8') as f:
            json.dump(entries, f, ensure_ascii=False, indent=2)

          # Commit and push (with PR fallback if branch protection blocks direct push)
          subprocess.run(['git','config','user.name','github-actions[bot]'], check=True)
          subprocess.run(['git','config','user.email','41898282+github-actions[bot]@users.noreply.github.com'], check=True)
          subprocess.run(['git','fetch','origin', target_branch], check=False)
          subprocess.run(['git','checkout', target_branch], check=False)
          subprocess.run(['git','pull','--ff-only','origin', target_branch], check=False)
          subprocess.run(['git','add', filename], check=True)
          msg = f"[bot] add attendance codes for {course} Week {week} (issue #{issue_no})"
          subprocess.run(['git','commit','-m', msg], check=True)

          direct_push_ok = True
          try:
              subprocess.run(['git','push','origin', target_branch], check=True)
          except subprocess.CalledProcessError:
              direct_push_ok = False

          pr_url = None
          if not direct_push_ok:
              # Create a branch and open a PR
              safe_course = re.sub(r'[^A-Za-z0-9]+','', course).upper()
              safe_week = re.sub(r'[^0-9]+','', week)
              branch_name = f"bot/codes-{safe_course}-w{safe_week}-issue-{issue_no}"
              subprocess.run(['git','checkout','-b', branch_name], check=True)
              try:
                  subprocess.run(['git','push','-u','origin', branch_name], check=True)
                  # Create PR
                  pr_create = subprocess.run([
                      'gh','pr','create',
                      '--title', msg,
                      '--body', f"Automated codes JSON for {course} Week {week} (from issue #{issue_no}).",
                      '--base', target_branch,
                      '--head', branch_name
                  ], check=True, capture_output=True, text=True)
                  pr_url = pr_create.stdout.strip().splitlines()[-1]
              except subprocess.CalledProcessError as e:
                  print('Failed to create PR:', e)

          # Comment success with raw URL hint
          raw = f"https://raw.githubusercontent.com/{repo}/{target_branch}/{filename}"
          ok = (
            f"Generated codes JSON: `{filename}`\n\n"
            f"Raw URL: {raw}\n\n"
            f"The script can use this URL directly by setting `CODES_URL={raw}`."
          )
          if pr_url:
              ok += f"\n\nDirect push was blocked; opened PR: {pr_url}"
          subprocess.run([
            'gh','api',
            f'repos/{repo}/issues/{issue_no}/comments',
            '--method','POST','-f',f'body={ok}'
          ], check=False)
          PY
