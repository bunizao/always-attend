name: Build attendance codes from issues

on:
  issues:
    types: [opened, edited]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process when running manually'
        required: false
  issue_comment:
    types: [created, edited]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  parse-and-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Verify tooling
        run: |
          set -euo pipefail
          git --version
          gh --version || echo "gh CLI not found"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Parse issue and commit codes JSON
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          DISPATCH_ISSUE_NUMBER: ${{ inputs.issue_number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          REPO: ${{ github.repository }}
          TARGET_BRANCH: main
        run: |
          set -euo pipefail
          python3 - << 'PY'
          import os, re, json, subprocess, sys, pathlib, urllib.request, base64, urllib.error, time
          from concurrent.futures import ThreadPoolExecutor, as_completed

          # Determine issue number from event (issues trigger) or manual input (workflow_dispatch)
          issue_no_raw = os.environ.get('ISSUE_NUMBER') or ''
          if not issue_no_raw.strip():
              issue_no_raw = os.environ.get('DISPATCH_ISSUE_NUMBER') or ''
          if not issue_no_raw.strip():
              print('No issue number provided in event or inputs; exiting without changes.')
              sys.exit(0)
          issue_no = int(issue_no_raw)
          repo = os.environ['REPO']
          title = os.environ.get('ISSUE_TITLE') or ''
          body = os.environ.get('ISSUE_BODY') or ''
          comment_body = os.environ.get('COMMENT_BODY') or ''
          # If title/body are missing (e.g., workflow_dispatch), fetch them via API
          if not title or not body:
              gh_token = os.environ.get('GITHUB_TOKEN') or os.environ.get('GH_TOKEN')
              api_path = f"https://api.github.com/repos/{repo}/issues/{issue_no}"
              try:
                  # Prefer gh if available
                  out = subprocess.run(['gh','api', f'repos/{repo}/issues/{issue_no}'], capture_output=True, text=True, check=True)
                  issue_json = json.loads(out.stdout)
                  title = title or issue_json.get('title') or ''
                  body = body or issue_json.get('body') or ''
              except Exception:
                  if gh_token:
                      req = urllib.request.Request(api_path, headers={
                          'Authorization': f'Bearer {gh_token}',
                          'Accept': 'application/vnd.github+json',
                          'User-Agent': 'attendance-bot'
                      })
                      with urllib.request.urlopen(req) as resp:
                          issue_json = json.loads(resp.read().decode('utf-8'))
                          title = title or issue_json.get('title') or ''
                          body = body or issue_json.get('body') or ''
          target_branch = os.environ.get('TARGET_BRANCH','main')

          def parse_issue_form_text(body_text: str):
              """Parse GitHub Issue Form sections: Course code, Week number, Attendance codes.

              Returns (course:str|None, week:str|None, pairs:list[(slot,code)]).
              """
              course = None
              week = None
              pairs = []

              # Common Issue Forms render as markdown headings like:
              # ### Course code\nFIT1111\n\n### Week number\n3\n\n### Attendance codes\n...
              sec = {
                  'course': r"(?mis)^###\s*Course\s*code\s*\n+([^\n#]+)",
                  'week': r"(?mis)^###\s*Week\s*number\s*\n+([^\n#]+)",
                  'codes': r"(?mis)^###\s*Attendance\s*codes\s*\n+(.+?)(?:\n###\s|\Z)",
              }
              m = re.search(sec['course'], body_text)
              if m:
                  course = re.sub(r"[^A-Za-z0-9]+", "", m.group(1)).upper() or None
              m = re.search(sec['week'], body_text)
              if m:
                  wk = re.sub(r"[^0-9]+", "", m.group(1))
                  week = wk if wk else None
              m = re.search(sec['codes'], body_text)
              if m:
                  code_block = m.group(1)
                  for line in code_block.splitlines():
                      line = line.strip()
                      if not line:
                          continue
                      # Accept optional list markers and flexible spacing
                      # Allow ASCII colon ':', full-width colon '：', hyphen '-', en dash '–', em dash '—'
                      mm = re.match(r"^[-*+]?\s*([^:：\-–—]+?)\s*(?:[:：\-–—])\s*([A-Za-z0-9]{4,12})\s*$", line)
                      if mm:
                          slot, code = mm.group(1).strip(), mm.group(2).strip().upper()
                          pairs.append((slot, code))
              return course, week, pairs

          def call_gemini_api(api_key, issue_title, issue_body):
              prompt = f'''
              Task: From the GitHub Issue content below, extract the course code, week number (integer), and attendance codes.

              Rules and format:
              - course: a 3-letter + 4-digit code (e.g., FIT1111).
              - week: integer only (e.g., "Week 3" -> 3).
              - codes: an array of objects, each with:
                - slot: the row/group/session name (e.g., "Workshop 1", "Applied 2").
                - code: the attendance code (alphanumeric only, uppercase).
              - If the body describes a table and says the rightmost column is the code, parse rows accordingly: take the rightmost column as code, and the left-most descriptive column as slot. Ignore headers.
              - If course or week is missing, set it to null. If no codes found, return [].
              - Return a single, minified JSON object only (no Markdown or explanation).

              Output JSON keys: "course", "week", "codes".

              ---
              Issue Title: {issue_title}
              ---
              Issue Body:
              {issue_body}
              '''
              
              api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key={api_key}"
              
              headers = {"Content-Type": "application/json"}
              
              data = {
                  "contents": [{
                      "role": "user",
                      "parts": [{
                          "text": prompt
                      }]
                  }],
                  "generationConfig": {
                      "responseMimeType": "application/json",
                  }
              }
              
              req = urllib.request.Request(api_url, data=json.dumps(data).encode("utf-8"), headers=headers)
              
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status == 200:
                          response_body = response.read().decode("utf-8")
                          response_json = json.loads(response_body)
                          return response_json['candidates'][0]['content']['parts'][0]['text']
              except urllib.error.HTTPError as e:
                  print(f"Gemini API request failed with status: {e.code}")
                  print(e.read().decode())
                  return None
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")
                  return None

          def call_gemini_api_with_image(api_key, image_data, mime_type):
              prompt = '''
              Task: Extract attendance data from the attached table screenshot and output strict JSON only.

              Parsing rules (table-focused):
              - Treat the rightmost column as the attendance code (code). Ignore similar text in other columns.
              - For each row, set slot to the row's session/group/time label (usually a left-most descriptive column, e.g., "Workshop 1", "Applied 2", "Lab A").
              - Set code to the value from the rightmost column (alphanumeric, uppercase). Ignore header, empty, or separator rows.

              Other fields:
              - course: extract a 3-letters + 4-digits code like FIT1111 if present; otherwise null.
              - week: extract an integer week number if present; otherwise null.

              Output requirements: return only minified JSON, no Markdown, no prose. Shape:
              {"course": string|null, "week": integer|null, "codes": [{"slot": string, "code": string}]}
              '''
              
              api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key={api_key}"
              
              headers = {"Content-Type": "application/json"}
              
              data = {
                  "contents": [{
                      "role": "user",
                      "parts": [
                          {"text": prompt},
                          {
                              "inlineData": {
                                  "mimeType": mime_type,
                                  "data": image_data
                              }
                          }
                      ]
                  }],
                  "generationConfig": {
                      "responseMimeType": "application/json",
                  }
              }
              
              req = urllib.request.Request(api_url, data=json.dumps(data).encode("utf-8"), headers=headers)
              
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status == 200:
                          response_body = response.read().decode("utf-8")
                          response_json = json.loads(response_body)
                          return response_json['candidates'][0]['content']['parts'][0]['text']
              except urllib.error.HTTPError as e:
                  print(f"Gemini API request failed with status: {e.code}")
                  print(e.read().decode())
                  return None

          def call_openai_api(api_key, prompt):
              url = "https://api.openai.com/v1/chat/completions"
              headers = {
                  "Authorization": f"Bearer {api_key}",
                  "Content-Type": "application/json",
              }
              body = {
                  "model": "gpt-4o-mini",
                  "response_format": {"type": "json_object"},
                  "messages": [
                      {"role": "system", "content": "You are a precise extractor. Only output minified JSON with keys course, week, codes."},
                      {"role": "user", "content": prompt},
                  ],
              }
              req = urllib.request.Request(url, data=json.dumps(body).encode("utf-8"), headers=headers)
              try:
                  with urllib.request.urlopen(req) as resp:
                      if resp.status == 200:
                          out = json.loads(resp.read().decode("utf-8"))
                          return out["choices"][0]["message"]["content"]
              except urllib.error.HTTPError as e:
                  print("OpenAI text request failed:", e.code, e.read().decode())
              except Exception as e:
                  print("OpenAI text error:", e)
              return None

          def call_openai_api_with_image(api_key, prompt, image_b64, mime_type):
              url = "https://api.openai.com/v1/chat/completions"
              headers = {
                  "Authorization": f"Bearer {api_key}",
                  "Content-Type": "application/json",
              }
              data_uri = f"data:{mime_type};base64,{image_b64}"
              body = {
                  "model": "gpt-4o-mini",
                  "response_format": {"type": "json_object"},
                  "messages": [
                      {"role": "system", "content": "You are a precise extractor. Only output minified JSON with keys course, week, codes."},
                      {
                          "role": "user",
                          "content": [
                              {"type": "text", "text": prompt},
                              {"type": "image_url", "image_url": {"url": data_uri}},
                          ],
                      },
                  ],
              }
              req = urllib.request.Request(url, data=json.dumps(body).encode("utf-8"), headers=headers)
              try:
                  with urllib.request.urlopen(req) as resp:
                      if resp.status == 200:
                          out = json.loads(resp.read().decode("utf-8"))
                          return out["choices"][0]["message"]["content"]
              except urllib.error.HTTPError as e:
                  print("OpenAI image request failed:", e.code, e.read().decode())
              except Exception as e:
                  print("OpenAI image error:", e)
              return None

          def parse_extracted_json(text):
              try:
                  data = json.loads(text)
              except Exception:
                  return None, None, []
              course = data.get("course")
              week_val = data.get("week")
              week = str(week_val) if (isinstance(week_val, int) or (isinstance(week_val, str) and week_val.strip())) else None
              pairs = []
              for item in data.get("codes") or []:
                  slot = (item.get("slot") or "").strip()
                  code = (item.get("code") or "").strip().upper()
                  if slot and code:
                      pairs.append((slot, code))
              return course, week, pairs
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")
                  return None

          # Aggregate text: issue body + latest comment (if present) for parsing
          aggregate_text = body
          if comment_body:
              aggregate_text += "\n\n" + comment_body

          # First, try deterministic parsing from the Issue Form
          course, week, pairs = parse_issue_form_text(aggregate_text)

          gemini_api_key = os.environ.get('GEMINI_API_KEY')
          openai_api_key = os.environ.get('OPENAI_API_KEY')
          ai_text_summary = ''
          ai_image_summary = ''

          # Image-first: try OCR on any attached images before text parsing
          if not pairs:
              img_urls = re.findall(r'!\[[^\]]*\]\((https?://[^)]+)\)', aggregate_text)
              if img_urls:
                  if not (gemini_api_key or openai_api_key):
                      print("Image(s) found but no AI keys set; skipping OCR.")
                  for url in img_urls:
                      try:
                          with urllib.request.urlopen(url) as resp:
                              image_bytes = resp.read()
                              content_type = resp.info().get_content_type()
                              image_b64 = base64.b64encode(image_bytes).decode("utf-8")
                              calls = []
                              if gemini_api_key:
                                  calls.append(("gemini", lambda: call_gemini_api_with_image(gemini_api_key, image_b64, content_type)))
                              if openai_api_key:
                                  calls.append(("openai", lambda: call_openai_api_with_image(openai_api_key,
                                      "Task: Extract attendance from the table screenshot. Rightmost column is the code; slot is the left-most descriptive column. Return minified JSON with keys course, week, codes.", image_b64, content_type)))
                              img_results = {}
                              with ThreadPoolExecutor(max_workers=len(calls) or 1) as ex:
                                  fut_map = {ex.submit(fn): name for name, fn in calls}
                                  for fut in as_completed(fut_map):
                                      name = fut_map[fut]
                                      try:
                                          txt = fut.result()
                                      except Exception as e:
                                          print(f"{name} image error: {e}")
                                          txt = None
                                      if txt:
                                          c, w, p = parse_extracted_json(txt)
                                          img_results[name] = {"course": c, "week": w, "pairs": p, "raw": txt}
                              if img_results:
                                  ai_image_summary = ", ".join([f"{k}:{len(v['pairs'])}" for k,v in img_results.items()])
                                  best_img = max(img_results.items(), key=lambda kv: (len(kv[1]["pairs"]), 1 if kv[0]=="gemini" else 0))
                                  provider, data_best = best_img
                                  if data_best["pairs"]:
                                      if not course:
                                          course = data_best["course"]
                                      if not week:
                                          week = data_best["week"]
                                      if not pairs:
                                          pairs = data_best["pairs"]
                              if pairs:
                                  break
                      except Exception as e:
                          print(f"Failed to process image at {url}: {e}")

          # If still missing, optionally try Gemini on text
          if (not course or not week or not pairs) and (gemini_api_key or openai_api_key):
              prompts = {
                  "gemini": (lambda: call_gemini_api(gemini_api_key, title, body)) if gemini_api_key else None,
                  "openai": (lambda: call_openai_api(openai_api_key, (
                      "Task: From the GitHub Issue content below, extract the course code, week number (integer), and attendance codes.\n\n"
                      "Rules and format:\n"
                      "- course: a 3-letter + 4-digit code (e.g., FIT1111).\n"
                      "- week: integer only (e.g., \"Week 3\" -> 3).\n"
                      "- codes: array of {slot, code}; code alphanumeric uppercase.\n"
                      "- If the body describes a table with rightmost column as code, use rightmost column as code and a left-most descriptive column as slot; ignore headers.\n"
                      "- If course/week missing, set null; if no codes, return [].\n"
                      "- Return a single minified JSON only.\n\n"
                      f"---\nIssue Title: {title}\n---\nIssue Body:\n{body}\n"
                  ))) if openai_api_key else None,
              }
              results = {}
              with ThreadPoolExecutor(max_workers=2) as ex:
                  fut_map = {}
                  for name, fn in prompts.items():
                      if fn:
                          fut = ex.submit(fn)
                          fut_map[fut] = name
                  for fut in as_completed(fut_map):
                      name = fut_map[fut]
                      try:
                          txt = fut.result()
                      except Exception as e:
                          print(f"{name} text error: {e}")
                          txt = None
                      if txt:
                          c, w, p = parse_extracted_json(txt)
                          results[name] = {"course": c, "week": w, "pairs": p, "raw": txt}
              # choose best
              best = None
              if results:
                  ai_text_summary = ", ".join([f"{k}:{len(v['pairs'])}" for k,v in results.items()])
                  # Prefer provider with more codes; tie-breaker prefer gemini
                  best = max(results.items(), key=lambda kv: (len(kv[1]["pairs"]), 1 if kv[0]=="gemini" else 0))
                  provider, data_best = best
                  if data_best["pairs"]:
                      if not course:
                          course = data_best["course"]
                      if not week:
                          week = data_best["week"]
                      if not pairs:
                          pairs = data_best["pairs"]

          # Image block already attempted above; keep this disabled to avoid duplicate work
          if False and not pairs:
              img_urls = re.findall(r'!\[[^\]]*\]\((https?://[^)]+)\)', body)
              if img_urls:
                  if not (gemini_api_key or openai_api_key):
                      print("Image(s) found but no AI keys set; skipping OCR.")
                  
                  for url in img_urls:
                      try:
                          with urllib.request.urlopen(url) as resp:
                              image_bytes = resp.read()
                              content_type = resp.info().get_content_type()
                              image_b64 = base64.b64encode(image_bytes).decode("utf-8")
                              calls = []
                              if gemini_api_key:
                                  calls.append(("gemini", lambda: call_gemini_api_with_image(gemini_api_key, image_b64, content_type)))
                              if openai_api_key:
                                  calls.append(("openai", lambda: call_openai_api_with_image(openai_api_key, \
                                      "Task: Extract attendance from the table screenshot. Rightmost column is the code; slot is the left-most descriptive column. Return minified JSON with keys course, week, codes.", image_b64, content_type)))
                              img_results = {}
                              with ThreadPoolExecutor(max_workers=len(calls) or 1) as ex:
                                  fut_map = {ex.submit(fn): name for name, fn in calls}
                                  for fut in as_completed(fut_map):
                                      name = fut_map[fut]
                                      try:
                                          txt = fut.result()
                                      except Exception as e:
                                          print(f"{name} image error: {e}")
                                          txt = None
                                      if txt:
                                          c, w, p = parse_extracted_json(txt)
                                          img_results[name] = {"course": c, "week": w, "pairs": p, "raw": txt}
                              if img_results:
                                  ai_image_summary = ", ".join([f"{k}:{len(v['pairs'])}" for k,v in img_results.items()])
                                  best_img = max(img_results.items(), key=lambda kv: (len(kv[1]["pairs"]), 1 if kv[0]=="gemini" else 0))
                                  provider, data_best = best_img
                                  if data_best["pairs"]:
                                      if not course:
                                          course = data_best["course"]
                                      if not week:
                                          week = data_best["week"]
                                      if not pairs:
                                          pairs = data_best["pairs"]
                              if pairs:
                                  break
                      except Exception as e:
                          print(f"Failed to process image at {url}: {e}")

          # Optional: brief comparison comment if both providers returned results
          def summarize(ai_results):
              return ", ".join([f"{k}: {len(v['pairs'])} codes" for k,v in ai_results.items()]) if ai_results else ""

          # If still no pairs, ask user to provide proper text
          if not pairs:
            comment = (
              "Could not identify attendance codes from the issue.\n\n"
              "Please provide the codes in the issue body in the following format, or upload a clearer screenshot:\n\n"
              "```\nWorkshop 1: JZXBA\nWorkshop 2: AJYV7\nApplied 1: 6B7UF\n...\n```\n\nAlso, please specify the following in the body:\n\n- Course code (e.g., FIT1111)\n- Week number (e.g., Week 3)\n\nThe workflow will automatically retry after the issue is updated."
            )
            if img_urls and not (gemini_api_key or openai_api_key):
              comment += "\n\nNote: A screenshot was detected, but OCR is disabled because `GEMINI_API_KEY`/`OPENAI_API_KEY` secrets are not set in this repository."
            subprocess.run([
              'gh','api',
              f'repos/{repo}/issues/{issue_no}/comments',
              '--method','POST','-f',f'body={comment}'
            ], check=False)
            sys.exit(0)

          # If pairs are found but course/week missing, request them
          if not course or not week:
            missing = []
            if not course: missing.append('课程代码（如 FIT1111）')
            if not week: missing.append('Week 编号（如 Week 3）')
            comment = (
              "Attendance codes have been identified, but the following information is missing: " + ", ".join(missing) + ".\n\n"
              "Please add the missing information to the issue body:\n\n- Course code (e.g., FIT1111)\n- Week number (e.g., Week 3)\n\nThe JSON file will be generated automatically after the issue is updated."
            )
            subprocess.run([
              'gh','api',
              f'repos/{repo}/issues/{issue_no}/comments',
              '--method','POST','-f',f'body={comment}'
            ], check=False)
            sys.exit(0)

          # Update issue title
          new_title = f"{course} Week {week}: Attendance codes"
          subprocess.run([
            'gh','issue','edit',str(issue_no),
            '--title', new_title
          ], check=False)

          # Build JSON entries for codes
          entries = []
          for slot, code in pairs:
            entries.append({
              'slot': slot.strip(),
              'date': None,
              'code': code.strip().upper(),
            })

          # File path under data/{course}/{week}.json
          safe_course = re.sub(r'[^A-Za-z0-9]+','', course).upper()
          safe_week = re.sub(r'[^0-9]+','', week)
          if not safe_week:
            raise SystemExit('Week number must be an integer')
          out_dir = pathlib.Path('data') / safe_course
          out_dir.mkdir(parents=True, exist_ok=True)
          filename = str(out_dir / f"{safe_week}.json")
          with open(filename,'w',encoding='utf-8') as f:
            json.dump(entries, f, ensure_ascii=False, indent=2)

          # Commit and push (with PR fallback if branch protection blocks direct push)
          subprocess.run(['git','config','user.name','github-actions[bot]'], check=True)
          subprocess.run(['git','config','user.email','41898282+github-actions[bot]@users.noreply.github.com'], check=True)
          subprocess.run(['git','fetch','origin', target_branch], check=False)
          subprocess.run(['git','checkout', target_branch], check=False)
          subprocess.run(['git','pull','--ff-only','origin', target_branch], check=False)
          subprocess.run(['git','add', filename], check=True)
          msg = f"[bot] add attendance codes for {course} Week {week} (issue #{issue_no})"
          subprocess.run(['git','commit','-m', msg], check=True)

          direct_push_ok = True
          try:
              subprocess.run(['git','push','origin', target_branch], check=True)
          except subprocess.CalledProcessError:
              direct_push_ok = False

          pr_url = None
          if not direct_push_ok:
              # Create a branch and open a PR
              safe_course = re.sub(r'[^A-Za-z0-9]+','', course).upper()
              safe_week = re.sub(r'[^0-9]+','', week)
              branch_name = f"bot/codes-{safe_course}-w{safe_week}-issue-{issue_no}"
              subprocess.run(['git','checkout','-b', branch_name], check=True)
              try:
                  subprocess.run(['git','push','-u','origin', branch_name], check=True)
                  # Create PR
                  pr_create = subprocess.run([
                      'gh','pr','create',
                      '--title', msg,
                      '--body', f"Automated codes JSON for {course} Week {week} (from issue #{issue_no}).",
                      '--base', target_branch,
                      '--head', branch_name
                  ], check=True, capture_output=True, text=True)
                  pr_url = pr_create.stdout.strip().splitlines()[-1]
              except subprocess.CalledProcessError as e:
                  print('Failed to create PR:', e)

          # Comment success with raw URL hint
          raw = f"https://raw.githubusercontent.com/{repo}/{target_branch}/{filename}"
          ok = (
            f"Generated codes JSON: `{filename}`\n\n"
            f"Raw URL: {raw}\n\n"
            f"The script can use this URL directly by setting `CODES_URL={raw}`."
          )
          if ai_text_summary or ai_image_summary:
              ok += "\n\nAI parsing summary: " + "; ".join(filter(None, [f"text[{ai_text_summary}]" if ai_text_summary else '', f"image[{ai_image_summary}]" if ai_image_summary else '']))
          if pr_url:
              ok += f"\n\nDirect push was blocked; opened PR: {pr_url}"
          subprocess.run([
            'gh','api',
            f'repos/{repo}/issues/{issue_no}/comments',
            '--method','POST','-f',f'body={ok}'
          ], check=False)
          PY
