name: Build attendance codes from issues

on:
  issues:
    types: [opened, edited]

permissions:
  contents: write
  issues: write

jobs:
  parse-and-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Parse issue and commit codes JSON
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          REPO: ${{ github.repository }}
          TARGET_BRANCH: main
        run: |
          set -euo pipefail
          python3 - << 'PY'
          import os, re, json, subprocess, sys, tempfile, pathlib, urllib.request, base64

          issue_no = int(os.environ['ISSUE_NUMBER'])
          title = os.environ.get('ISSUE_TITLE') or ''
          body = os.environ.get('ISSUE_BODY') or ''
          repo = os.environ['REPO']
          target_branch = os.environ.get('TARGET_BRANCH','main')

          def call_gemini_api(api_key, issue_title, issue_body):
              # Note: Using gemini-1.5-flash as gemini-2.5-flash is not a valid model at this time.
              prompt = f'''
From the following GitHub issue title and body, extract the course code, week number, and attendance codes.
- The course code is a 3-letter, 4-digit code (e.g., FIT1111).
- The week number is an integer.
- The attendance codes are pairs of a slot (e.g., "Workshop 1") and a code (e.g., "JZXBA").

Return the result as a single, minified JSON object with no markdown formatting. The JSON object should have these keys: "course", "week", "codes".
- The "course" value should be a string.
- The "week" value should be an integer.
- The "codes" key should hold an array of objects, where each object has a "slot" and "code" key.

If the course code or week number cannot be found, return null for those fields.
If no attendance codes can be found, return an empty array for the "codes" field.

---
Issue Title: {issue_title}
---
Issue Body:
{issue_body}
'''
              
              api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}"
              
              headers = {"Content-Type": "application/json"}
              
              data = {
                  "contents": [{
                      "parts": [{
                          "text": prompt
                      }]
                  }],
                  "generationConfig": {
                      "response_mime_type": "application/json",
                  }
              }
              
              req = urllib.request.Request(api_url, data=json.dumps(data).encode("utf-8"), headers=headers)
              
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status == 200:
                          response_body = response.read().decode("utf-8")
                          response_json = json.loads(response_body)
                          return response_json['candidates'][0]['content']['parts'][0]['text']
              except urllib.error.HTTPError as e:
                  print(f"Gemini API request failed with status: {e.code}")
                  print(e.read().decode())
                  return None
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")
                  return None

          def call_gemini_api_with_image(api_key, image_data, mime_type):
              prompt = '''
From the attached image, extract the course code, week number, and attendance codes.
The course code is a 3-letter, 4-digit code (e.g., FIT1111).
The week number is an integer.
The attendance codes are pairs of a slot (e.g., "Workshop 1") and a code (e.g., "JZXBA").

Return the result as a single, minified JSON object with no markdown formatting. The JSON object should have these keys: "course", "week", "codes".
- The "course" value should be a string.
- The "week" value should be an integer.
- The "codes" key should hold an array of objects, where each object has a "slot" and "code" key.

If the course code or week number cannot be found, return null for those fields.
If no attendance codes can be found, return an empty array for the "codes" field.
'''
              
              api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={api_key}"
              
              headers = {"Content-Type": "application/json"}
              
              data = {
                  "contents": [{
                      "parts": [
                          {"text": prompt},
                          {
                              "inline_data": {
                                  "mime_type": mime_type,
                                  "data": image_data
                              }
                          }
                      ]
                  }],
                  "generationConfig": {
                      "response_mime_type": "application/json",
                  }
              }
              
              req = urllib.request.Request(api_url, data=json.dumps(data).encode("utf-8"), headers=headers)
              
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status == 200:
                          response_body = response.read().decode("utf-8")
                          response_json = json.loads(response_body)
                          return response_json['candidates'][0]['content']['parts'][0]['text']
              except urllib.error.HTTPError as e:
                  print(f"Gemini API request failed with status: {e.code}")
                  print(e.read().decode())
                  return None
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")
                  return None

          gemini_api_key = os.environ.get('GEMINI_API_KEY')
          if not gemini_api_key:
              print("GEMINI_API_KEY secret is not set. Skipping AI processing and exiting.")
              sys.exit(1)

          # Try to get data from text first
          extracted_data_json = call_gemini_api(gemini_api_key, title, body)
          course = None
          week = None
          pairs = []
          if extracted_data_json:
              try:
                  extracted_data = json.loads(extracted_data_json)
                  course = extracted_data.get("course")
                  week = str(extracted_data.get("week")) if extracted_data.get("week") else None
                  if extracted_data.get("codes"):
                      for item in extracted_data.get("codes"):
                          pairs.append((item.get("slot"), item.get("code")))
              except json.JSONDecodeError:
                  print("Failed to decode JSON from Gemini text response.")

          # If no pairs from text, try image
          if not pairs:
              img_urls = re.findall(r'!\\[^\\]*\\]\((https?://[^)]+)\)', body)
              if img_urls:
                  for url in img_urls:
                      try:
                          with urllib.request.urlopen(url) as resp:
                              image_bytes = resp.read()
                              content_type = resp.info().get_content_type()
                              image_b64 = base64.b64encode(image_bytes).decode("utf-8")
                              
                              extracted_data_json = call_gemini_api_with_image(gemini_api_key, image_b64, content_type)
                              if extracted_data_json:
                                  extracted_data = json.loads(extracted_data_json)
                                  course = extracted_data.get("course")
                                  week = str(extracted_data.get("week")) if extracted_data.get("week") else None
                                  if extracted_data.get("codes"):
                                      for item in extracted_data.get("codes"):
                                          pairs.append((item.get("slot"), item.get("code")))
                                  # If we got something from the first image, we can stop.
                                  if pairs:
                                      break
                      except Exception as e:
                          print(f"Failed to process image at {url}: {e}")

          # If still no pairs, ask user to provide proper text
          if not pairs:
            comment = (
              "Could not identify attendance codes from the issue.\n\n"
              "Please provide the codes in the issue body in the following format, or upload a clearer screenshot:\n\n"
              "```\nWorkshop 1: JZXBA\nWorkshop 2: AJYV7\nApplied 1: 6B7UF\n...\n```\n\nAlso, please specify the following in the body:\n\n- Course code (e.g., FIT1111)\n- Week number (e.g., Week 3)\n\nThe workflow will automatically retry after the issue is updated."
            )
            subprocess.run([
              'gh','api',
              f'repos/{repo}/issues/{issue_no}/comments',
              '--method','POST','-f',f'body={comment}'
            ], check=False)
            sys.exit(0)

          # If pairs are found but course/week missing, request them
          if not course or not week:
            missing = []
            if not course: missing.append('课程代码（如 FIT1111）')
            if not week: missing.append('Week 编号（如 Week 3）')
            comment = (
              "Attendance codes have been identified, but the following information is missing: " + ", ".join(missing) + ".\n\n"
              "Please add the missing information to the issue body:\n\n- Course code (e.g., FIT1111)\n- Week number (e.g., Week 3)\n\nThe JSON file will be generated automatically after the issue is updated."
            )
            subprocess.run([
              'gh','api',
              f'repos/{repo}/issues/{issue_no}/comments',
              '--method','POST','-f',f'body={comment}'
            ], check=False)
            sys.exit(0)

          # Update issue title
          new_title = f"{course} Week {week}: Attendance codes"
          subprocess.run([
            'gh','issue','edit',str(issue_no),
            '--title', new_title
          ], check=False)

          # Build JSON entries for codes
          entries = []
          for slot, code in pairs:
            entries.append({
              'slot': slot.strip(),
              'date': None,
              'code': code.strip().upper(),
            })

          # File path under data/{course}/{week}.json
          safe_course = re.sub(r'[^A-Za-z0-9]+','', course).upper()
          safe_week = re.sub(r'[^0-9]+','', week)
          if not safe_week:
            raise SystemExit('Week number must be an integer')
          out_dir = pathlib.Path('data') / safe_course
          out_dir.mkdir(parents=True, exist_ok=True)
          filename = str(out_dir / f"{safe_week}.json")
          with open(filename,'w',encoding='utf-8') as f:
            json.dump(entries, f, ensure_ascii=False, indent=2)

          # Commit and push
          subprocess.run(['git','config','user.name','github-actions[bot]'], check=True)
          subprocess.run(['git','config','user.email','41898282+github-actions[bot]@users.noreply.github.com'], check=True)
          subprocess.run(['git','add', filename], check=True)
          msg = f"[bot] add attendance codes for {course} Week {week} (issue #{issue_no})"
          subprocess.run(['git','commit','-m', msg], check=True)
          subprocess.run(['git','push','origin', target_branch], check=True)

          # Comment success with raw URL hint
          raw = f"https://raw.githubusercontent.com/{repo}/{target_branch}/{filename}"
          ok = (
            f"Generated codes JSON: `{filename}`\n\n"
            f"Raw URL: {raw}\n\n"
            f"The script can use this URL directly by setting `CODES_URL={raw}`."
          )
          subprocess.run([
            'gh','api',
            f'repos/{repo}/issues/{issue_no}/comments',
            '--method','POST','-f',f'body={ok}'
          ], check=False)
          PY
