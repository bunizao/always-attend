name: Build attendance codes from issues

on:
  issues:
    types: [opened, edited]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process when running manually'
        required: false

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  parse-and-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Verify tooling
        run: |
          set -euo pipefail
          git --version
          gh --version || echo "gh CLI not found"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Parse issue and commit codes JSON
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          DISPATCH_ISSUE_NUMBER: ${{ inputs.issue_number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          REPO: ${{ github.repository }}
          TARGET_BRANCH: main
        run: |
          set -euo pipefail
          python3 - << 'PY'
          import os, re, json, subprocess, sys, pathlib, urllib.request, base64

          # Determine issue number from event (issues trigger) or manual input (workflow_dispatch)
          issue_no_raw = os.environ.get('ISSUE_NUMBER') or ''
          if not issue_no_raw.strip():
              issue_no_raw = os.environ.get('DISPATCH_ISSUE_NUMBER') or ''
          if not issue_no_raw.strip():
              print('No issue number provided in event or inputs; exiting without changes.')
              sys.exit(0)
          issue_no = int(issue_no_raw)
          repo = os.environ['REPO']
          title = os.environ.get('ISSUE_TITLE') or ''
          body = os.environ.get('ISSUE_BODY') or ''
          # If title/body are missing (e.g., workflow_dispatch), fetch them via API
          if not title or not body:
              gh_token = os.environ.get('GITHUB_TOKEN') or os.environ.get('GH_TOKEN')
              api_path = f"https://api.github.com/repos/{repo}/issues/{issue_no}"
              try:
                  # Prefer gh if available
                  out = subprocess.run(['gh','api', f'repos/{repo}/issues/{issue_no}'], capture_output=True, text=True, check=True)
                  issue_json = json.loads(out.stdout)
                  title = title or issue_json.get('title') or ''
                  body = body or issue_json.get('body') or ''
              except Exception:
                  if gh_token:
                      req = urllib.request.Request(api_path, headers={
                          'Authorization': f'Bearer {gh_token}',
                          'Accept': 'application/vnd.github+json',
                          'User-Agent': 'attendance-bot'
                      })
                      with urllib.request.urlopen(req) as resp:
                          issue_json = json.loads(resp.read().decode('utf-8'))
                          title = title or issue_json.get('title') or ''
                          body = body or issue_json.get('body') or ''
          target_branch = os.environ.get('TARGET_BRANCH','main')

          def parse_issue_form_text(body_text: str):
              """Parse GitHub Issue Form sections: Course code, Week number, Attendance codes.

              Returns (course:str|None, week:str|None, pairs:list[(slot,code)]).
              """
              course = None
              week = None
              pairs = []

              # Common Issue Forms render as markdown headings like:
              # ### Course code\nFIT1111\n\n### Week number\n3\n\n### Attendance codes\n...
              sec = {
                  'course': r"(?mis)^###\s*Course\s*code\s*\n+([^\n#]+)",
                  'week': r"(?mis)^###\s*Week\s*number\s*\n+([^\n#]+)",
                  'codes': r"(?mis)^###\s*Attendance\s*codes\s*\n+(.+?)(?:\n###\s|\Z)",
              }
              m = re.search(sec['course'], body_text)
              if m:
                  course = re.sub(r"[^A-Za-z0-9]+", "", m.group(1)).upper() or None
              m = re.search(sec['week'], body_text)
              if m:
                  wk = re.sub(r"[^0-9]+", "", m.group(1))
                  week = wk if wk else None
              m = re.search(sec['codes'], body_text)
              if m:
                  code_block = m.group(1)
                  for line in code_block.splitlines():
                      line = line.strip()
                      if not line:
                          continue
                      # Accept optional list markers and flexible spacing
                      # Allow ASCII colon ':', full-width colon '：', hyphen '-', en dash '–', em dash '—'
                      mm = re.match(r"^[-*+]?\s*([^:：\-–—]+?)\s*(?:[:：\-–—])\s*([A-Za-z0-9]{4,12})\s*$", line)
                      if mm:
                          slot, code = mm.group(1).strip(), mm.group(2).strip().upper()
                          pairs.append((slot, code))
              return course, week, pairs

          def call_gemini_api(api_key, issue_title, issue_body):
              prompt = f'''
              Task: From the GitHub Issue content below, extract the course code, week number (integer), and attendance codes.

              Rules and format:
              - course: a 3-letter + 4-digit code (e.g., FIT1111).
              - week: integer only (e.g., "Week 3" -> 3).
              - codes: an array of objects, each with:
                - slot: the row/group/session name (e.g., "Workshop 1", "Applied 2").
                - code: the attendance code (alphanumeric only, uppercase).
              - If the body describes a table and says the rightmost column is the code, parse rows accordingly: take the rightmost column as code, and the left-most descriptive column as slot. Ignore headers.
              - If course or week is missing, set it to null. If no codes found, return [].
              - Return a single, minified JSON object only (no Markdown or explanation).

              Output JSON keys: "course", "week", "codes".

              ---
              Issue Title: {issue_title}
              ---
              Issue Body:
              {issue_body}
              '''
              
              api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key={api_key}"
              
              headers = {"Content-Type": "application/json"}
              
              data = {
                  "contents": [{
                      "parts": [{
                          "text": prompt
                      }]
                  }],
                  "generationConfig": {
                      "response_mime_type": "application/json",
                  }
              }
              
              req = urllib.request.Request(api_url, data=json.dumps(data).encode("utf-8"), headers=headers)
              
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status == 200:
                          response_body = response.read().decode("utf-8")
                          response_json = json.loads(response_body)
                          return response_json['candidates'][0]['content']['parts'][0]['text']
              except urllib.error.HTTPError as e:
                  print(f"Gemini API request failed with status: {e.code}")
                  print(e.read().decode())
                  return None
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")
                  return None

          def call_gemini_api_with_image(api_key, image_data, mime_type):
              prompt = '''
              Task: Extract attendance data from the attached table screenshot and output strict JSON only.

              Parsing rules (table-focused):
              - Treat the rightmost column as the attendance code (code). Ignore similar text in other columns.
              - For each row, set slot to the row's session/group/time label (usually a left-most descriptive column, e.g., "Workshop 1", "Applied 2", "Lab A").
              - Set code to the value from the rightmost column (alphanumeric, uppercase). Ignore header, empty, or separator rows.

              Other fields:
              - course: extract a 3-letters + 4-digits code like FIT1111 if present; otherwise null.
              - week: extract an integer week number if present; otherwise null.

              Output requirements: return only minified JSON, no Markdown, no prose. Shape:
              {"course": string|null, "week": integer|null, "codes": [{"slot": string, "code": string}]}
              '''
              
              api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key={api_key}"
              
              headers = {"Content-Type": "application/json"}
              
              data = {
                  "contents": [{
                      "parts": [
                          {"text": prompt},
                          {
                              "inline_data": {
                                  "mime_type": mime_type,
                                  "data": image_data
                              }
                          }
                      ]
                  }],
                  "generationConfig": {
                      "response_mime_type": "application/json",
                  }
              }
              
              req = urllib.request.Request(api_url, data=json.dumps(data).encode("utf-8"), headers=headers)
              
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status == 200:
                          response_body = response.read().decode("utf-8")
                          response_json = json.loads(response_body)
                          return response_json['candidates'][0]['content']['parts'][0]['text']
              except urllib.error.HTTPError as e:
                  print(f"Gemini API request failed with status: {e.code}")
                  print(e.read().decode())
                  return None
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")
                  return None

          # First, try deterministic parsing from the Issue Form
          course, week, pairs = parse_issue_form_text(body)

          gemini_api_key = os.environ.get('GEMINI_API_KEY')

          # If still missing, optionally try Gemini on text
          if (not course or not week or not pairs) and gemini_api_key:
              extracted_data_json = call_gemini_api(gemini_api_key, title, body)
              if extracted_data_json:
                  try:
                      extracted_data = json.loads(extracted_data_json)
                      course = course or extracted_data.get("course")
                      week = week or (str(extracted_data.get("week")) if extracted_data.get("week") else None)
                      if not pairs and extracted_data.get("codes"):
                          for item in extracted_data.get("codes"):
                              pairs.append((item.get("slot"), item.get("code")))
                  except json.JSONDecodeError:
                      print("Failed to decode JSON from Gemini text response.")

          # If still no pairs, try image OCR via Gemini (if key present)
          if not pairs:
              img_urls = re.findall(r'!\[[^\]]*\]\((https?://[^)]+)\)', body)
              if img_urls:
                  if not gemini_api_key:
                      print("Image(s) found but GEMINI_API_KEY not set; skipping OCR.")
                  
                  for url in img_urls:
                      try:
                          with urllib.request.urlopen(url) as resp:
                              image_bytes = resp.read()
                              content_type = resp.info().get_content_type()
                              image_b64 = base64.b64encode(image_bytes).decode("utf-8")
                              if not gemini_api_key:
                                  continue
                              extracted_data_json = call_gemini_api_with_image(gemini_api_key, image_b64, content_type)
                              if extracted_data_json:
                                  extracted_data = json.loads(extracted_data_json)
                                  course = course or extracted_data.get("course")
                                  week = week or (str(extracted_data.get("week")) if extracted_data.get("week") else None)
                                  if not pairs and extracted_data.get("codes"):
                                      for item in extracted_data.get("codes"):
                                          pairs.append((item.get("slot"), item.get("code")))
                                  # If we got something from the first image, we can stop.
                                  if pairs:
                                      break
                      except Exception as e:
                          print(f"Failed to process image at {url}: {e}")

          # If still no pairs, ask user to provide proper text
          if not pairs:
            comment = (
              "Could not identify attendance codes from the issue.\n\n"
              "Please provide the codes in the issue body in the following format, or upload a clearer screenshot:\n\n"
              "```\nWorkshop 1: JZXBA\nWorkshop 2: AJYV7\nApplied 1: 6B7UF\n...\n```\n\nAlso, please specify the following in the body:\n\n- Course code (e.g., FIT1111)\n- Week number (e.g., Week 3)\n\nThe workflow will automatically retry after the issue is updated."
            )
            subprocess.run([
              'gh','api',
              f'repos/{repo}/issues/{issue_no}/comments',
              '--method','POST','-f',f'body={comment}'
            ], check=False)
            sys.exit(0)

          # If pairs are found but course/week missing, request them
          if not course or not week:
            missing = []
            if not course: missing.append('课程代码（如 FIT1111）')
            if not week: missing.append('Week 编号（如 Week 3）')
            comment = (
              "Attendance codes have been identified, but the following information is missing: " + ", ".join(missing) + ".\n\n"
              "Please add the missing information to the issue body:\n\n- Course code (e.g., FIT1111)\n- Week number (e.g., Week 3)\n\nThe JSON file will be generated automatically after the issue is updated."
            )
            subprocess.run([
              'gh','api',
              f'repos/{repo}/issues/{issue_no}/comments',
              '--method','POST','-f',f'body={comment}'
            ], check=False)
            sys.exit(0)

          # Update issue title
          new_title = f"{course} Week {week}: Attendance codes"
          subprocess.run([
            'gh','issue','edit',str(issue_no),
            '--title', new_title
          ], check=False)

          # Build JSON entries for codes
          entries = []
          for slot, code in pairs:
            entries.append({
              'slot': slot.strip(),
              'date': None,
              'code': code.strip().upper(),
            })

          # File path under data/{course}/{week}.json
          safe_course = re.sub(r'[^A-Za-z0-9]+','', course).upper()
          safe_week = re.sub(r'[^0-9]+','', week)
          if not safe_week:
            raise SystemExit('Week number must be an integer')
          out_dir = pathlib.Path('data') / safe_course
          out_dir.mkdir(parents=True, exist_ok=True)
          filename = str(out_dir / f"{safe_week}.json")
          with open(filename,'w',encoding='utf-8') as f:
            json.dump(entries, f, ensure_ascii=False, indent=2)

          # Commit and push (with PR fallback if branch protection blocks direct push)
          subprocess.run(['git','config','user.name','github-actions[bot]'], check=True)
          subprocess.run(['git','config','user.email','41898282+github-actions[bot]@users.noreply.github.com'], check=True)
          subprocess.run(['git','fetch','origin', target_branch], check=False)
          subprocess.run(['git','checkout', target_branch], check=False)
          subprocess.run(['git','pull','--ff-only','origin', target_branch], check=False)
          subprocess.run(['git','add', filename], check=True)
          msg = f"[bot] add attendance codes for {course} Week {week} (issue #{issue_no})"
          subprocess.run(['git','commit','-m', msg], check=True)

          direct_push_ok = True
          try:
              subprocess.run(['git','push','origin', target_branch], check=True)
          except subprocess.CalledProcessError:
              direct_push_ok = False

          pr_url = None
          if not direct_push_ok:
              # Create a branch and open a PR
              safe_course = re.sub(r'[^A-Za-z0-9]+','', course).upper()
              safe_week = re.sub(r'[^0-9]+','', week)
              branch_name = f"bot/codes-{safe_course}-w{safe_week}-issue-{issue_no}"
              subprocess.run(['git','checkout','-b', branch_name], check=True)
              try:
                  subprocess.run(['git','push','-u','origin', branch_name], check=True)
                  # Create PR
                  pr_create = subprocess.run([
                      'gh','pr','create',
                      '--title', msg,
                      '--body', f"Automated codes JSON for {course} Week {week} (from issue #{issue_no}).",
                      '--base', target_branch,
                      '--head', branch_name
                  ], check=True, capture_output=True, text=True)
                  pr_url = pr_create.stdout.strip().splitlines()[-1]
              except subprocess.CalledProcessError as e:
                  print('Failed to create PR:', e)

          # Comment success with raw URL hint
          raw = f"https://raw.githubusercontent.com/{repo}/{target_branch}/{filename}"
          ok = (
            f"Generated codes JSON: `{filename}`\n\n"
            f"Raw URL: {raw}\n\n"
            f"The script can use this URL directly by setting `CODES_URL={raw}`."
          )
          if pr_url:
              ok += f"\n\nDirect push was blocked; opened PR: {pr_url}"
          subprocess.run([
            'gh','api',
            f'repos/{repo}/issues/{issue_no}/comments',
            '--method','POST','-f',f'body={ok}'
          ], check=False)
          PY
